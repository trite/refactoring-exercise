// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

var doThingsAndStuff = (function(x) {
        var temp = [];
        var temp2;
        var tmep3;
        var temp4;

        while(x.length) { // while there are items left in x
            temp2 = x.pop(); // pop the end off x and set temp2 to it, mutates x
            if (!temp2) continue; // skip to end of iteration if pop() returned undefined
            for (tmep3 = 0; tmep3 < temp2.length; tmep3++) // iterate the length of temp2 via temp3
                if (temp2 && temp2.charCodeAt(tmep3) == 32) { // is the character at this point a space?
                    var start = tmep3++ + 1; // increment tmep3 by 1, set start to that same value in a terrible way
                    var doBreak = false; // break clause to skip additional iterations in some situations
                    var isFound = false; // whether the thing we're looking for was found -- looks like this makes the comparison happen if a space has occurred in the string previously
                    for (temp4 = 0; temp4 < temp.length; temp4++) { // iterate through items in temp (shouldn't be anything on the first pass)
                        if (doBreak) {
                            break;
                        }
                        tmep3 = start; // tmep3 can be incremented below potentially, so this might matter
                        isFound = false; 
                        for (var y = 0; y < temp[temp4].length; y++) { // iterate through the string currently being looked at from temp array

                            // If the string contains a space, then the code after this can run
                            // Otherwise this will skip the rest of the for loop
                            if (!isFound && temp[temp4].charCodeAt(y) == 32) {
                                isFound = true;
                                continue;
                            } else if (!isFound) {
                                continue;
                            }

                            // first part skips the compare if there's no character at tmep3, which is possible since it increments at line 12 and cound again at line 42
                            if (!temp2.charCodeAt(tmep3) || temp2.charCodeAt(tmep3) < temp[temp4].charCodeAt(y)) {
                                temp4--; 
                                if (temp4 < 0) {
                                    temp4 = 0;
                                }
                                temp.splice(temp4, 0, temp2); // insert temp2 at index temp4
                                /*
                                    const months = ['Jan', 'March', 'April', 'June'];
                                    months.splice(1, 0, 'Feb');
                                    // inserts at index 1
                                    console.log(months);
                                    // expected output: Array ["Jan", "Feb", "March", "April", "June"]
                                */
                                doBreak = true;
                                break;
                            } else if (temp2.charCodeAt(tmep3) == temp[temp4].charCodeAt(y)) {
                                tmep3++; // every other scenario breaks, this is the only one that continues iterating on tmep3
                                continue;
                            } else {
                                doBreak = true;
                                break;
                            }
                        }
                    }
                    isFound = false;

                    // Only add items that aren't already added, hence why the same amount of spaces are only added once
                    for (temp4 = 0; temp4 < temp.length; temp4++) // this also shouldn't run on first pass
                        if (temp2 === temp[temp4]) {
                            isFound = true;
                            break;
                        }

                    // If item isn't previously in temp add it to the end of the array
                    if (!isFound) {
                        temp.push(temp2);
                    }
                    break
                }
        };
        while(temp.length) {
            var newThing = temp.pop();
            x.push(newThing);
        };
    });

function insertAt(start, toInsert, arr) {
  var arrStart = Belt_Array.slice(arr, 0, start);
  var arrEnd = Belt_Array.slice(arr, start, arr.length - start | 0);
  return Belt_Array.concatMany([
              arrStart,
              [toInsert],
              arrEnd
            ]);
}

function advanceState1(state) {
  var len = state.pullFrom.length;
  if (len <= 0) {
    return {
            TAG: /* DoneState */3,
            _0: state.pushTo
          };
  }
  var rest = Belt_Array.slice(state.pullFrom, 0, len - 1 | 0);
  var pop = Caml_array.get(state.pullFrom, len - 1 | 0);
  return {
          TAG: /* State2 */1,
          _0: {
            pullFrom: rest,
            pushTo: state.pushTo,
            examining: pop,
            examPosition: 0,
            spaceInExam: false
          }
        };
}

function arrContains(lookFor, arr) {
  return Belt_Option.isSome(Caml_option.undefined_to_opt(arr.find(function (x) {
                      return x === lookFor;
                    })));
}

function advanceState2(state) {
  var charTest = state.examining.charCodeAt(state.examPosition);
  var nextPosition = state.examPosition + 1 | 0;
  if (charTest === 32.0) {
    if (state.pushTo.length > 0) {
      return {
              TAG: /* State3 */2,
              _0: {
                pullFrom: state.pullFrom,
                pushTo: state.pushTo,
                examining: state.examining,
                examPositionReset: nextPosition,
                examPosition: nextPosition,
                spaceInExam: true,
                comparing: Caml_array.get(state.pushTo, 0),
                comparingSource: 0,
                comparePosition: 0,
                spaceInCompare: false
              }
            };
    } else {
      return {
              TAG: /* State2 */1,
              _0: {
                pullFrom: state.pullFrom,
                pushTo: state.pushTo,
                examining: state.examining,
                examPosition: nextPosition,
                spaceInExam: true
              }
            };
    }
  }
  if (!Number.isNaN(charTest)) {
    return {
            TAG: /* State2 */1,
            _0: {
              pullFrom: state.pullFrom,
              pushTo: state.pushTo,
              examining: state.examining,
              examPosition: nextPosition,
              spaceInExam: state.spaceInExam
            }
          };
  }
  var pushTo = state.spaceInExam && !arrContains(state.examining, state.pushTo) ? Belt_Array.concat(state.pushTo, [state.examining]) : state.pushTo;
  return {
          TAG: /* State1 */0,
          _0: {
            pullFrom: state.pullFrom,
            pushTo: pushTo
          }
        };
}

function advanceState3(state) {
  if (state.spaceInCompare) {
    var examCharCode = state.examining.charCodeAt(state.examPosition);
    var compareCharCode = state.comparing.charCodeAt(state.comparePosition);
    if (Number.isNaN(examCharCode) || examCharCode < compareCharCode) {
      return {
              TAG: /* State1 */0,
              _0: {
                pullFrom: state.pullFrom,
                pushTo: insertAt(state.comparingSource - 1 | 0, state.examining, state.pushTo)
              }
            };
    }
    if (examCharCode === compareCharCode) {
      return {
              TAG: /* State3 */2,
              _0: {
                pullFrom: state.pullFrom,
                pushTo: state.pushTo,
                examining: state.examining,
                examPositionReset: state.examPositionReset,
                examPosition: state.examPosition + 1 | 0,
                spaceInExam: state.spaceInExam,
                comparing: state.comparing,
                comparingSource: state.comparingSource,
                comparePosition: state.comparePosition,
                spaceInCompare: state.spaceInCompare
              }
            };
    }
    var pushTo = arrContains(state.examining, state.pushTo) ? state.pushTo : Belt_Array.concat(state.pushTo, [state.examining]);
    return {
            TAG: /* State1 */0,
            _0: {
              pullFrom: state.pullFrom,
              pushTo: pushTo
            }
          };
  }
  var charTest = state.examining.charCodeAt(state.examPosition);
  if (Number.isNaN(charTest)) {
    var pushTo$1 = state.spaceInExam ? Belt_Array.concat(state.pushTo, [state.examining]) : state.pushTo;
    return {
            TAG: /* State1 */0,
            _0: {
              pullFrom: state.pullFrom,
              pushTo: pushTo$1
            }
          };
  }
  var spaces = charTest === 32.0;
  return {
          TAG: /* State3 */2,
          _0: {
            pullFrom: state.pullFrom,
            pushTo: state.pushTo,
            examining: state.examining,
            examPositionReset: state.examPositionReset,
            examPosition: state.examPosition + 1 | 0,
            spaceInExam: state.spaceInExam,
            comparing: state.comparing,
            comparingSource: state.comparingSource,
            comparePosition: state.comparePosition,
            spaceInCompare: spaces || state.spaceInCompare
          }
        };
}

function newVersionInner(_outerState) {
  while(true) {
    var outerState = _outerState;
    switch (outerState.TAG | 0) {
      case /* State1 */0 :
          _outerState = advanceState1(outerState._0);
          continue ;
      case /* State2 */1 :
          _outerState = advanceState2(outerState._0);
          continue ;
      case /* State3 */2 :
          _outerState = advanceState3(outerState._0);
          continue ;
      case /* DoneState */3 :
          return Belt_Array.reverse(outerState._0);
      
    }
  };
}

function newVersion(arr) {
  return newVersionInner({
              TAG: /* State1 */0,
              _0: {
                pullFrom: arr,
                pushTo: []
              }
            });
}

console.log(newVersion([
          " foo",
          "bar "
        ]));

function checking(arr) {
  var left = newVersion(arr.slice());
  var right = arr.slice();
  doThingsAndStuff(right);
  console.log("===================");
  console.log(left);
  console.log(right);
  console.log("");
  
}

checking([
      " foo",
      "bar "
    ]);

checking([
      "foo",
      " ",
      "bar"
    ]);

checking([
      "   ",
      "foo",
      " ",
      "bar",
      "     "
    ]);

checking([
      "     ",
      " ",
      "   "
    ]);

checking([
      "     ",
      "   ",
      " "
    ]);

checking([
      "1",
      " 2",
      "3 ",
      " 4 ",
      "  5",
      "6  ",
      "  7  ",
      "8 8 8",
      " 9 9 "
    ]);

checking([
      "a",
      " b",
      "c ",
      "d",
      "eeeee",
      "f  f",
      "gg",
      "  "
    ]);

exports.doThingsAndStuff = doThingsAndStuff;
exports.insertAt = insertAt;
exports.advanceState1 = advanceState1;
exports.arrContains = arrContains;
exports.advanceState2 = advanceState2;
exports.advanceState3 = advanceState3;
exports.newVersionInner = newVersionInner;
exports.newVersion = newVersion;
exports.checking = checking;
/*  Not a pure module */
